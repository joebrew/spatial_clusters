---
params:
  example_param: 1
  creation_date: !r as.Date(Sys.Date())
fig_height: 2.6
fig_width: 4
author: Joe Brew and Lucia Fernandez
output:
  html_document:
    toc: true
    toc_float: true
    theme: spacelab
---

---
title: Efficient assignation of spatial clusters
---

```{r, echo = FALSE, warning = FALSE, message = FALSE, comment = NA, error= FALSE, cache = FALSE}
# No scientific notation
options(scipen=999)

# Packages 
library(xtable)
library(knitr)
library(Hmisc)
library(raster)
library(maptools)
library(rgeos)
library(plyr)
library(dplyr)
library(sp)

# Basic knitr options
opts_chunk$set(comment = NA, echo = FALSE, warning = FALSE, message = FALSE, error = FALSE, cache = F)

# Parameters into memory out of list
# Specify paramaters
for (i in 1:length(params)){
  assign(names(params)[i],
         params[[i]],
         env = .GlobalEnv)
}
```

```{r}
# Machine and user info
si <- Sys.info()
technical_message <-
  paste0('(Generated on ',
         format(creation_date, '%B %d, %Y'),
         '\nBy ',
         si['user'],
         '\nOn a ',
         si['nodename'], 
         ' ',
         si['sysname'],
         '\nMachine using R version ',
         si['release'],
         ')')
rm(si)
```

`r paste0(technical_message)`

# The problem

We have a geographical area (the district of Manhiça, for the purposes of this example), with a number of households (1,000, for the purpose of this example). We need to assign each household to a cluster of a specific size (10, for this example). Since 1 field-worker will be assigned to each cluster, we want to minimize the inter-cluster distance (ie, the distance between households in each cluster). The intra-cluster distance (ie, the distance between clusters) is irrelevant.

# The approach

We use a computational, rather than statistical, approach to solving this problem. In simple terms, our algorithm does the following.  

1. Picks a random household to begin. 
2. Picks the nearest 9 households to form a cluster.
3. Starts a new cluster, beginning with the household for which the average distance to remaining households is the lowest.
4. Picks the nearest 9 houeholds to form a cluster.
5. Repeats until all households have been assigned to a cluster.
6. Repeats steps 1-5 multiple times, so that results can be compared and the ideal configuration can be chosen.

# Walk-through

We start with the district of Maniça.

```{r, echo = TRUE}
# Get a spatialpolygonsdataframe of mozambique
moz <- getData('GADM', country = 'MOZ', level = 2)

# Subset to just include manhica
man <- moz[moz@data$NAME_2 == 'Manhiça', ]

# Visualize
plot(man)
```

We then create 1000 random points (in real practice, actual household locations can be used).

```{r, echo = TRUE}
# Create a dataframe named locations for storing our points in
locations <- data.frame(id = 1:1000, 
                        lat = NA,
                        lon = NA)

# Get the range for Manhica
bb <- bbox(man)

# Populate locations
for (i in 1:nrow(locations)){
  
  # Create a placeholder to indicate whether our point is in Manhica
  in_man <- FALSE
  
  # If not in manhica, create a point in manhica
  while(!in_man){
    # Create a point
    lon <- sample(seq(bb[1,1],
                      bb[1,2],
                      length = 10000),
                  1)
    lat <- sample(seq(bb[2,1],
                      bb[2,2],
                      length = 10000),
                  1)
    # Put that point into a spatial dataframe
    the_point <- data.frame(lon = lon,
                            lat = lat)
    coordinates(the_point) <- ~lon+lat
    proj4string(the_point) <- proj4string(man)
    
    # Check to see if it's in the boundaries of Manhica
    in_man <- as.logical(!is.na(over(man, the_point)))
  }
  # having confirmed that the point is in manhica, 
  # pop it into the dataframe
  locations$lon[i] <- lon
  locations$lat[i] <- lat
}

# Make locations a spatial points dataframe and plot
locations$x <- locations$lon
locations$y <- locations$lat
coordinates(locations) <- ~x +y
proj4string(locations) <- proj4string(man)
plot(man)
points(locations, 
       col = adjustcolor('red', alpha.f = 0.3), 
       pch = 3)
```

Now the heavy-lifting begins. We will do steps 1-5 (mentioned above) 20 times to test.

```{r}
# Source our function
source('cluster_optimize.R')
# run
x = cluster_optimize(times = 1,
                     cluster_size = 5,
                     sleep = 0.3,
                     plot_map = TRUE,
                     locations = locations,
                     best_only = TRUE)

```
